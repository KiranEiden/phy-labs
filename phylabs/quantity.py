import numpy
import sympy
import re

from functools import reduce
from collections import namedtuple
from enum import Enum
from threading import Lock

from sympy.utilities.lambdify import lambdify
import sympy.parsing.sympy_parser as symparse

# TODO: SymPy based expression parser fails on 'N*m'
# TODO: Define Quantity.__format__
# TODO: Better Quantity string representations
# TODO: Better UnitContainer string representations
# TODO: Add definitions of constants
# TODO: Pretty printing in iPython and Jupyter notebooks
# TODO: Arrays of quantities with different units?

class Ops(Enum):
    """ Operation lambdas """

    ADD = lambda a, b: a + b
    SUB = lambda a, b: a - b
    MUL = lambda a, b: a * b
    DIV = lambda a, b: a / b
    POW = lambda a, b: a ** b
    NEG = lambda a: -a

class UnitOps(Enum):
    """ Options for handling units when operating on quantities """

    @staticmethod
    def handle_dim_in(args, _, __):
        """ Make every input Quantity object dimensionless. """

        args = tuple(arg.to(None) if isquantity(arg) else arg
                     for arg in args)
        units = UnitContainer(None)
        return args, units

    @staticmethod
    def handle_dim_out(args, _, __):
        """ Make the output dimensionless. """

        args = tuple(arg.to(None) if isquantity(arg) else arg
                     for arg in args)
        units = UnitContainer(None)
        return args, units

    @staticmethod
    def handle_retain(args, units, _):
        """ Retain units of first argument. """

        assert len(args) == 1, "Single-argument function"
        return args, units[0]

    @staticmethod
    def handle_apply(args, units, numf):
        """ Apply function to units. """

        return args, numf(*units)

    @staticmethod
    def handle_add(args, units, _):
        """ Convert all args to units of the first argument. """

        args = tuple(arg.to(units[0]) if isquantity(arg) else arg
                     for arg in args)
        return args, units[0]

    @staticmethod
    def handle_sub(args, units, _):
        """ Convert all args to units of the first argument, convert units to delta. """

        args = tuple(arg.to(units[0]) if isquantity(arg) else arg
                     for arg in args)
        return args, units[0].delta

    @staticmethod
    def handle_pow(args, units, numf):
        """ Apply function to units. """

        funargs = (units[i] if units[i] else float(args[i])
                   for i in range(len(args)))
        return args, numf(*funargs)

    # Require dimensionless arguments
    DIM_IN = handle_dim_in
    # Dimensionless output
    DIM_OUT = handle_dim_out
    # Single argument, retain units
    RETAIN = handle_retain
    # Apply operation to units
    APPLY = handle_apply
    # Convert to units of first argument
    ADD = handle_add
    # Convert to units of first argument
    SUB = handle_sub
    # Convert to units of first argument
    POW = handle_pow

##############################################################
#                        Quantities                          #
##############################################################

class AtomicCounter:

    def __init__(self, initial=0):
        """Initialize a new atomic counter to given initial value (default 0)."""

        self.value = initial
        self._lock = Lock()

    def __call__(self, num=1):
        """ Atomically increment the counter by num (default 1) and return the new value. """

        with self._lock:
            self.value += num
            return self.value

class Quantity:
    """ Hybrid numeric and symbolic quantities. """

    # Subscript for autogenerated symbols
    _counter = AtomicCounter()

    def __init__(self, data, sigma=None, sym=None, units=None, expr=None, deps=None):

        # Set data, symbol, expression
        self._data = data
        self._locked = False
        self._sym = None
        self.set_sym(sym)
        self._expr = expr

        if isinstance(data, float) and self._data % 1 == 0.0:
            self._data = int(self._data)

        if sym is None and expr is None:
            self.set_sym(f"quantity_{Quantity._counter()}")

        self._unnamed = False
        if self.sym is None:
            self._unnamed = True
        elif re.match(r"quantity_(\d+)", str(self._sym)):
            self._unnamed = True

        # Units
        self.units = UnitContainer(units)

        # Set uncertainty
        if sigma is None or isinstance(sigma, Sigma):
            self._sigma = sigma
        elif isinstance(sigma, Quantity):
            self._sigma = Sigma(self, sigma.data, sigma.units, sigma.expr, sigma.deps)
        else:
            self._sigma = Sigma(self, sigma, units=self.units)

        if self._sigma is not None:
            self._sigma = self._sigma.to(self.units.delta)

        # Direct dependencies
        if deps is None:
            self.deps = set()
        else:
            self.deps = deps

    def __repr__(self):

        if self.unnamed:
            symstr = ""
        else:
            symstr = f"{self.sym} = "

        if self.sigma is None or not self.sigma:
            sigstr = ""
        else:
            sigstr = f" ± {self.sigma.data}"

        unitstr = str(self.units)
        if self.units:
            unitstr = " " + unitstr

        return f"{symstr}{self.data}{sigstr}{unitstr}"

    #############################
    #   Operation Definitions   #
    #############################

    def __abs__(self):

        return execute_op(abs, self, unitop=UnitOps.RETAIN)

    def __add__(self, other):

        return execute_op(Ops.ADD, self, other, unitop=UnitOps.ADD)

    def __radd__(self, other):

        return execute_op(Ops.ADD, other, self, unitop=UnitOps.ADD)

    def __sub__(self, other):

        return execute_op(Ops.SUB, self, other, unitop=UnitOps.SUB)

    def __rsub__(self, other):

        return execute_op(Ops.SUB, other, self, unitop=UnitOps.SUB)

    def __mul__(self, other):

        return execute_op(Ops.MUL, self, other, unitop=UnitOps.APPLY)

    def __rmul__(self, other):

        return execute_op(Ops.MUL, other, self, unitop=UnitOps.APPLY)

    def __truediv__(self, other):

        return execute_op(Ops.DIV, self, other, unitop=UnitOps.APPLY)

    def __rtruediv__(self, other):

        return execute_op(Ops.DIV, other, self, unitop=UnitOps.APPLY)

    def __pow__(self, other):

        return execute_op(Ops.POW, self, other, unitop=UnitOps.POW)

    def __rpow__(self, other):

        return execute_op(Ops.POW, other, self, unitop=UnitOps.POW)

    def __neg__(self):

        return execute_op(Ops.NEG, self, unitop=UnitOps.RETAIN)

    ########################
    #   Type Conversions   #
    ########################

    def __bool__(self):

        nonzero = (self.data != 0.0)

        if isinstance(nonzero, bool):
            return nonzero
        else:
            return bool(nonzero.all())

    def __float__(self):

        return float(self.data)

    ###########################
    #   Misc. Functionality   #
    ###########################

    def _propagate_uncertainty(self):

        deps = tuple(self.deps)
        dep_symbols = tuple(dep.sym for dep in deps)
        uncertain_deps = tuple(dep for dep in deps if dep.sigma is not None)
        if not uncertain_deps: return None

        derivs = (sympy.diff(self.expr, dep.sym) for dep in uncertain_deps)
        terms = ((deriv * dep.sigma.sym)**2 for deriv, dep in zip(derivs, uncertain_deps))
        sigma_expr = sympy.sqrt(sum(terms))

        dep_sigmas = tuple(dep.sigma for dep in uncertain_deps)
        dep_sigma_syms = tuple(sigma.sym for sigma in dep_sigmas)
        sigma_func = lambdify(dep_symbols + dep_sigma_syms, sigma_expr, 'numpy')

        sigma_deps = deps + dep_sigmas
        sigma_deps_data = tuple(dep.to_base_units().data for dep in sigma_deps)
        sigma_data = sigma_func(*sigma_deps_data)

        sigma = Sigma(self, sigma_data, self.units.base_units, sigma_expr, sigma_deps)
        return sigma.to(self.units.delta)

    def lock_sym(self):
        """ Lock symbol to prevent name changes. """

        self._locked = True

    def set_sym(self, sym):
        """ Set symbol for this Quantity. The Quantity must be unlocked. """

        if sym is None: return
        assert not self._locked, "Can only rename symbols that have not been used in any operations"

        if not isinstance(sym, sympy.Symbol):
            self._sym = sympy.Symbol(sym)
        else:
            self._sym = sym

    def to(self, units):
        """
        Returns a Quantity expressing the current one in the new units. Only generates a new object
        if a conversion is necessary -- otherwise returns the current object.
        """

        units = UnitContainer(units)

        if self.units == units:

            return self

        if self.units.dimensionality != units.dimensionality:

            raise DimensionalityError(f"Cannot convert between {self.units.dimensionality} " +
                                      f"and {units.dimensionality}")

        other_scale, other_offset = units.to_base
        scale, offset = self.units.to_base

        new_data = (scale * self._data + offset - other_offset) / other_scale
        if self._sigma is not None:
            new_sigma = self._sigma.to(units.delta)
        else:
            new_sigma = None

        return Quantity(new_data, new_sigma, self._sym, units, self._expr, self.deps)

    def to_base_units(self):
        """
        Returns a Quantity expressing the current one base units.
        """

        if self.units.are_base_units:
            return self

        scale, offset = self.units.to_base

        new_data = scale * self._data + offset
        if self._sigma is not None:
            new_sigma = self._sigma.to_base_units()
        else:
            new_sigma = None

        return Quantity(new_data, new_sigma, self._sym, self.units.base_units, self._expr, self.deps)

    ############################
    #   Read-only Properties   #
    ############################

    @property
    def data(self):

        return self._data

    @property
    def sigma(self):

        if self._sigma is None and self._expr is not None:
            self._sigma =  self._propagate_uncertainty()
        return self._sigma

    @property
    def unnamed(self):

        return self._unnamed

    @property
    def sym(self):

        return self._sym

    @property
    def expr(self):

        if self._expr is None:
            return self.sym
        return self._expr

    @property
    def locked(self):

        return self._locked


class Sigma(Quantity):
    """ Auxiliary class for storing uncertainties. """

    def __init__(self, parent, data, units=None, expr=None, deps=None):

        if parent.sym is None:
            sym = None
        else:
            sym = f'sigma_{parent.sym}'

        super().__init__(data, sym=sym, units=units, expr=expr, deps=deps)

        if self.units.dimensionality != parent.units.dimensionality:

            raise DimensionalityError(f"Quantity ({parent.units.dimensionality}) and " +
                                      f"uncertainty ({self.units.dimensionality}) must " +
                                      "have the same dimensionality!")

        self.units = self.units.delta

        if parent.unnamed:
            self._unnamed = True


#########################################################
#                        Units                          #
#########################################################

class Dimension:
    """ Class for representing a type of dimension (e.g. length, time, etc.) """

    # Dimension registry
    _dreg = dict()

    def __new__(cls, desc):

        if desc in Dimension._dreg:
            return Dimension._dreg[desc]
        else:
            inst = super().__new__(cls)
            Dimension._dreg[desc] = inst
            return inst

    def __init__(self, desc):

        self._desc = desc
        self._base = None

    def __repr__(self):

        return f"Dimension('{self.description}')"

    def __str__(self):

        return f"[{self.description}]"

    def __hash__(self):

        return hash(self.description)

    def __eq__(self, other):

        return self.description == other.description

    @classmethod
    def get(cls, desc):

        return cls._dreg[desc]

    @classmethod
    def exists(cls, desc):

        return desc in cls._dreg

    def set_base_unit(self, unit):

        assert self._base is None, f"Base unit already set for {self}!"
        self._base = unit

    @property
    def description(self):

        return self._desc

    @property
    def base_unit(self):

        return self._base


# Class for storing unit conversion information
UnitConversion = namedtuple("UnitConversion", "scale offset")


class Unit:
    """ Base class for representing units """

    # Unit registry
    _ureg = dict()

    def __new__(cls, full_name, defn=None, aliases=()):

        if not full_name:
            raise ValueError("Unit must have a name!")
        names = (full_name,) + tuple(aliases)
        registered = [name in Unit._ureg for name in names]

        if any(registered):

            existing_names = list(filter(lambda name: name in Unit._ureg, names))
            existing_units = [Unit._ureg[name] for name in existing_names]
            for i in range(len(existing_units)-1):
                if existing_units[i] != existing_units[i+1]:
                    raise ValueError(f"{existing_names} exist with conflicting definitions.")

            if not registered[0]:
                raise ValueError("Unit alias registered, but full name is not. Try using " +
                                 "Unit.rename to reset the full name.")

            if all(registered):
                return Unit._ureg[full_name]

            unit = Unit._ureg[full_name]
            for name in names:
                Unit._ureg[name] = unit
            return unit

        else:

            inst = super().__new__(cls)
            for name in names:
                Unit._ureg[name] = inst
            return inst

    def __init__(self, full_name, defn, aliases=()):

        self._full_name = full_name
        self._aliases = tuple(aliases)
        short_ind = numpy.argmin([len(n) for n in self.names])
        # noinspection PyTypeChecker
        self._short_name = self.names[short_ind]

        self._dim = Dimensionality()
        self._to_base = None

        if isinstance(defn, str):

            m = re.fullmatch('base_(?P<dim>\w+)', defn)

            if m:
                dim = Dimension.get(m.groupdict()['dim'])
                self._dim[dim] = 1.0
                dim.set_base_unit(self)
                self._to_base = UnitConversion(scale=1.0, offset=0.0)
            else:
                self._dim, self._to_base = self.parse_defn(defn)

        elif isinstance(defn, tuple):

            self._dim, self._to_base = defn

        if self.hasoffset:

            new_name = f"delta_{self.full_name}"
            conv = UnitConversion(self.to_base.scale, 0.0)
            new_aliases = tuple(f"delta_{al}" for al in aliases)
            self._delta = Unit(new_name, (self.dimensionality, conv), new_aliases)

        else:

            self._delta = None

    @staticmethod
    def parse_defn(defn):
        """
        Parse definition string, returning dimensionality and UnitConversion in terms of base unit
        for that dimensionality.
        """

        transformations = symparse.standard_transformations + \
                          (symparse.convert_xor, symparse.implicit_multiplication)
        expr = symparse.parse_expr(defn, transformations=transformations)

        # <mfac> is the multiplicative term, <offset> is the additive one

        if isinstance(expr, sympy.Add):
            mfac, offset = expr.args
            if isinstance(mfac, sympy.Number):
                # The offset came before the linear term
                temp = offset
                offset = mfac
                mfac = temp
        else:
            mfac, offset = expr, 0.0

        scale = 1.0

        if isinstance(mfac, sympy.Mul):
            mfac = mfac.evalf()
            if isinstance(mfac.args[0], sympy.Number):
                scale = mfac.args[0]
        elif isinstance(mfac, sympy.Number):
            scale = mfac.evalf()
        elif not (isinstance(mfac, sympy.Pow) or isinstance(mfac, sympy.Symbol)):
            raise ValueError(f"Invalid unit definition: {defn}")
        units = str((mfac / scale).nsimplify(tolerance=1e-5))
        if units == "1": units = None

        scale = float(scale)
        offset = float(offset)
        units = UnitContainer(units)

        # Note: <scale> and <offset> are to convert from <units> to this newly defined one
        # <to_base_scale> and <to_base_offset> are to convert from the new unit to base units

        to_base_scale = scale * units.to_base.scale
        to_base_offset = offset * units.to_base.scale + units.to_base.offset
        conv = UnitConversion(scale=to_base_scale, offset=to_base_offset)

        return units.dimensionality, conv

    def __repr__(self):

        return f"Unit('{self._full_name}')"

    def __str__(self):

        return self._short_name

    def __hash__(self):

        return hash(self._full_name)

    def __eq__(self, other):

        return self.full_name == other.full_name

    @classmethod
    def get(cls, name):

        return cls._ureg[name]

    @classmethod
    def exists(cls, name):

        return name in cls._ureg

    @classmethod
    def rename(cls, oldname, newname):

        unit = cls.get(oldname)
        unit._full_name = newname

        for name in unit.names:
            cls._ureg[name] = unit

    @classmethod
    def remove(cls, name):

        unit = cls.get(name)

        for name in unit.names:
            del cls._ureg[name]

    @property
    def full_name(self):

        return self._full_name

    @property
    def aliases(self):

        return self._aliases

    @property
    def names(self):

        return (self._full_name,) + self._aliases

    @property
    def dimensionality(self):

        return self._dim

    @property
    def to_base(self):

        return self._to_base

    @property
    def hasoffset(self):

        return self.to_base.offset != 0.0

    @property
    def delta(self):

        return self._delta


class CompositionBase(dict):
    """ Base class for composition of dimensionalities / units """

    KeyType = type(None)

    def __init__(self, *args, **kwargs):

        super().__init__(*args, **kwargs)

    def __getitem__(self, key):

        if not isinstance(key, self.KeyType):
            key = self.KeyType.get(key)

        return super().__getitem__(key)

    def __setitem__(self, key, value):

        if not isinstance(key, self.KeyType):
            key = self.KeyType.get(key)
        value = float(value)

        super().__setitem__(key, value)

    @staticmethod
    def _stringify(keys, values):

        keys = list(keys)
        values = list(values)

        comps = ['']*len(keys)

        for i in range(len(keys)):

            k, v = keys[i], values[i]

            if v % 1 == 0.0:
                v = int(v)

            if v == 1.0:
                comps[i] = f"{k}"
            elif v < 0.0:
                comps[i] = f"{k}**({v})"
            else:
                comps[i] = f"{k}**{v}"

        return '·'.join(comps)

    def __repr__(self):

        return self._stringify(map(repr, self.keys()), self.values())

    def __str__(self):

        return self._stringify(map(str, self.keys()), self.values())

    def __pow__(self, exponent):

        new_comp = dict()

        for key, val in self.items():
            new_comp[key] = val*exponent

        return self.__class__(new_comp)

    def __mul__(self, other):

        new_comp = dict()
        keys = set(self.keys()) | set(other.keys())

        for key in keys:
            new_comp[key] = self.get(key, 0.0) + other.get(key, 0.0)

        return self.__class__(new_comp)

    def __truediv__(self, other):

        new_comp = dict()
        keys = set(self.keys()) | set(other.keys())

        for key in keys:
            new_comp[key] = self.get(key, 0.0) - other.get(key, 0.0)

        return self.__class__(new_comp)

    def __bool__(self):

        keys = list(self.keys())
        for key in keys:
            if self[key] == 0.0:
                del self[key]
        return len(self) > 0

    def sqrt(self):

        return self**0.5

    def cbrt(self):

        return self**(1./3.)

# noinspection PyPep8Naming
def Composition(KeyType: type) -> type:
    """ Return type deriving from CompositionBase with the given key type. """

    return type(f"{KeyType}Composition", (CompositionBase,), dict(KeyType=KeyType))


# noinspection PyArgumentList,PyTypeChecker
class Dimensionality(Composition(Dimension)):
    """ Class for representing the dimensionality of units """

    def __repr__(self):

        if len(self) == 0:
            return "Dimension('dimensionless')"
        else:
            return super().__repr__()

    def __str__(self):

        if len(self) == 0:
            return "[dimensionless]"
        else:
            return super().__str__()

    @property
    def base_units(self):

        units = dict()
        for dim, exponent in self.items():
            units[dim.base_unit] = exponent
        return UnitContainer(units)

class DimensionalityError(ValueError):
    """ Error thrown when dimensionalities do not match but should """

    pass

# noinspection PyTypeChecker,PyArgumentList
class UnitContainer(Composition(Unit)):
    """ Container for compositions of units """

    def __init__(self, unitspec):

        if isinstance(unitspec, dict):
            super().__init__(unitspec)
        else:
            super().__init__()

        if isinstance(unitspec, str):

            if Unit.exists(unitspec):
                unit = Unit.get(unitspec)
                self[unit] = 1.0
            elif unitspec:
                for unit, exponent in self.extract_units(unitspec):
                    unit = Unit.get(unit)
                    self[unit] = exponent

        elif isinstance(unitspec, Unit):
            self[unitspec] = 1.0

        self.to_base = self.derive_conv(self)
        self.dimensionality = self.derive_dim(self)

        errstr = "Invalid operation '{}' involving offset unit. Use delta_ variant instead."
        for unit in self:
            if unit.hasoffset:
                if len(self) > 1:
                    raise ValueError(errstr.format('*'))
                elif self[unit] != 1.0:
                    raise ValueError(errstr.format('**'))

    @classmethod
    def extract_units(cls, unitstr):
        """ Extract units and exponents from a unit definition string. """

        transformations = symparse.standard_transformations + (symparse.convert_xor,)
        expr = symparse.parse_expr(unitstr, transformations=transformations)

        yield from cls._traverse_expr(expr)

    @classmethod
    def _traverse_expr(cls, expr):

        if isinstance(expr, sympy.Pow):

            a, b = expr.args
            if not (isinstance(a, sympy.Symbol) and isinstance(b, sympy.Number)):
                raise ValueError(f"{a}**{b} not allowed in unit expression, must be symbol to some power.")
            yield str(a), float(b)

        elif isinstance(expr, sympy.Symbol):

            yield str(expr), 1.0

        elif isinstance(expr, sympy.Mul):

            for arg in expr.args:
                yield from cls._traverse_expr(arg)

        elif isinstance(expr, sympy.Number):

            raise ValueError(f"Non-exponent number {expr} in unit expression not permitted.")

        else:

            raise ValueError(f"Invalid operation {expr.func.__name__} in unit expression.")

    @staticmethod
    def derive_conv(unitdict):

        scale = 1.0
        offset = 0.0

        for unit, exponent in unitdict.items():

            mulfac = unit.to_base.scale**exponent
            scale *= mulfac

            offset *= mulfac
            offset += unit.to_base.offset

        return UnitConversion(scale=scale, offset=offset)

    @staticmethod
    def derive_dim(unitdict):

        dim = Dimensionality()

        for unit, exponent in unitdict.items():

            dim *= unit.dimensionality**exponent

        return dim

    @property
    def are_base_units(self):

        return self.to_base.scale == 1.0 and self.to_base.offset == 0.0

    @property
    def base_units(self):

        return self.dimensionality.base_units

    @property
    def delta(self):

        if self.to_base.offset != 0.0:

            unit, = iter(self)
            return UnitContainer(unit.delta)

        return self

##############################################################
#                     Transformations                        #
##############################################################

def isquantity(arg):
    """ Check if object is an instance of Quantity. """

    return isinstance(arg, Quantity)

def numfilter(args):
    """ Convert any quantities to the underlying data. """

    return (arg.data if isquantity(arg) else arg
            for arg in args)

def symfilter(args):
    """ Convert any quantities to the underlying expression. """

    for arg in args:
        if isquantity(arg):
            yield arg.sym if arg.sym is not None else arg.expr
        else:
            yield arg

def unitfilter(args):
    """ Convert quantities to the associated units. """

    return tuple(arg.units if isquantity(arg) else UnitContainer(None)
                 for arg in args)

def set_union(a, b):

    return a | b

def make_deps(args):
    """ Make dependency set, and lock their symbolic representations. """

    quantities = filter(isquantity, args)
    deps = (q.deps if q.sym is None else {q} for q in quantities)
    deps = reduce(set_union, deps)
    for dep in deps:
        dep.lock_sym()
    return deps

def createf(numname, symname=None, unitop=UnitOps.RETAIN):
    """
    Create a function returning a Quantity (takes numpy and sympy names). Operates on both numeric
    and symbolic components. Can opt to only supply one name if they are the same.
    """

    if symname is None: symname = numname
    numf = getattr(numpy, numname)
    symf = getattr(sympy, symname)

    def f(*args):

        # noinspection PyCallingNonCallable
        args, units = unitop(args, unitfilter(args), numf)
        data = numf(*numfilter(args))
        expr = symf(*symfilter(args))
        deps = make_deps(args)
        return Quantity(data, expr=expr, units=units, deps=deps)

    return f

def execute_op(op, *args, unitop=UnitOps.APPLY):
    """
    Execute an operation returning a Quantity. Operates on both numeric
    and symbolic components.
    """

    # noinspection PyCallingNonCallable
    args, units = unitop(args, unitfilter(args), op)
    data = op(*numfilter(args))
    expr = op(*symfilter(args))
    deps = make_deps(args)
    return Quantity(data, expr=expr, units=units, deps=deps)

############################
#   Function Definitions   #
############################

sign = createf('sign', unitop=UnitOps.DIM_OUT)
sqrt = createf('sqrt', unitop=UnitOps.APPLY)
cbrt = createf('cbrt', unitop=UnitOps.APPLY)
sin = createf('sin', unitop=UnitOps.DIM_IN)
cos = createf('cos', unitop=UnitOps.DIM_IN)
tan = createf('tan', unitop=UnitOps.DIM_IN)
asin = createf('arcsin', 'asin', unitop=UnitOps.DIM_IN)
acos = createf('arccos', 'acos', unitop=UnitOps.DIM_IN)
atan = createf('arctan', 'atan', unitop=UnitOps.DIM_IN)
exp = createf('exp', unitop=UnitOps.DIM_IN)
log = createf('log', unitop=UnitOps.DIM_IN)
sinh = createf('sinh', unitop=UnitOps.DIM_IN)
cosh = createf('cosh', unitop=UnitOps.DIM_IN)
tanh = createf('tanh', unitop=UnitOps.DIM_IN)
floor = createf('floor', unitop=UnitOps.DIM_IN)
ceil = createf('ceil', 'ceiling', unitop=UnitOps.DIM_IN)
gcd = createf('gcd', unitop=UnitOps.DIM_IN)
lcm = createf('lcm', unitop=UnitOps.DIM_IN)
